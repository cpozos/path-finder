{"version":3,"sources":["PathVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/node.js","PathVisualizer/PathVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","onMouseDown","className","row","col","this","setState","isTarget","isStart","isWall","onMouseEnter","onMouseUp","id","handleMouseDown","Component","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","NodeModel","Infinity","previousNode","isVisited","node","Grid","rows","cols","startNode","targetNode","nodes","push","value","i","length","j","a","b","neighbors","filter","neighbor","unvisitedNeighbors","getUnvisitedNeighbors","PathVisualizer","grid","isMoussePressed","setStartNode","setTargetNode","toogleWallPropertyNode","setWallPropertyNode","visitedNodesInOrder","getAllNodes","closestNode","shift","updateUnvisitedNeighbors","dijkstra_2","nodesInShortestPathOrder","finishNode","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","setTimeout","animateShortestPath","document","getElementById","console","log","onClick","computeDijkstra","getNodes","map","rowIdx","nodeIdx","isStartNode","isTargetNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.fd9f48fb.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            onMouseDown:null,\r\n            className:''\r\n        }\r\n    }\r\n\r\n    componentDidMount(){\r\n\r\n    }\r\n\r\n    handleMouseDown(row, col){\r\n        this.setState({className:\"node isStart\"});\r\n        this.state.onMouseDown(row,col);\r\n    }\r\n\r\n    render(){ \r\n        const {\r\n            row,\r\n            col,\r\n            isTarget,\r\n            isStart,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n        } = this.props;\r\n\r\n        const className = \r\n            isTarget ? 'node-target'\r\n            : isStart ? 'node-start'\r\n            : isWall ? 'node-wall'\r\n            : '';\r\n        \r\n        this.state.onMouseDown = onMouseDown;\r\n\r\n        return (\r\n            <div\r\n                id={`node-${row}-${col}`}\r\n                className={`node ${className}`}\r\n                onMouseDown={() => this.handleMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp()}>\r\n            </div>\r\n        );\r\n    }\r\n}      ","export function dijkstra_2(grid){\r\n    grid.startNode.distance = 0;\r\n    \r\n    const visitedNodesInOrder = [];\r\n    let unvisitedNodes = grid.getAllNodes();\r\n\r\n    while (!!unvisitedNodes.length){\r\n\r\n      // Sort them \r\n      sortNodesByDistance(unvisitedNodes);\r\n\r\n      // Get the first element\r\n      const closestNode = unvisitedNodes.shift();\r\n\r\n      // Skip it if it is a wall\r\n      if (closestNode.isWall) continue;\r\n      // It has finished\r\n      if (closestNode.distance === Infinity){\r\n        return visitedNodesInOrder;\r\n      } \r\n\r\n      // Appends the closest one\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      \r\n      // Finish condition\r\n      if (closestNode === grid.targetNode) {\r\n        return visitedNodesInOrder;\r\n      }\r\n      \r\n      // Update unvisited neighbors\r\n      grid.updateUnvisitedNeighbors(closestNode);\r\n    }\r\n}\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {\r\n      sortNodesByDistance(unvisitedNodes);\r\n      const closestNode = unvisitedNodes.shift();\r\n      // If we encounter a wall, we skip it.\r\n      if (closestNode.isWall) continue;\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n\r\n  function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n  \r\n  function updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid.getNodes());\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n  \r\n  function getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const col = node.col;\r\n    const row = node.row;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n  }\r\n  \r\n  function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n  \r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called *after* the dijkstra method above.\r\n  export function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }","export class NodeModel{\r\n    constructor(row, col){\r\n        this.row = row;\r\n        this.col = col;\r\n        this.distance = Infinity;\r\n        this.isWall = false;\r\n        this.previousNode = null;\r\n        this.isVisited = false;\r\n    }\r\n\r\n    equals(node){\r\n        return this.row === node.row && this.col === node.col;\r\n    }\r\n}\r\n\r\nexport class Grid{\r\n    #nodes;\r\n\r\n    constructor(rows, cols){\r\n        this.#nodes = [];\r\n        this.startNode = new NodeModel(-1,-1);\r\n        this.targetNode = new NodeModel(-1,-1);\r\n        for (let row = 0; row < rows; row++) {\r\n            const nodes = [];\r\n            for (let col = 0; col < cols; col++) {\r\n                nodes.push(new NodeModel(row,col));\r\n            }\r\n            this.#nodes.push(nodes);\r\n        }\r\n    }\r\n\r\n    setStartNode(row, col){\r\n        this.startNode = this.#nodes[row][col];\r\n    }\r\n\r\n    setTargetNode(row,col){\r\n        this.targetNode = this.#nodes[row][col];\r\n    }\r\n\r\n    toogleWallPropertyNode(row,col){\r\n        const isWall = this.#nodes[row][col].isWall;\r\n        this.#nodes[row][col].isWall = !isWall;\r\n    }\r\n\r\n    setWallPropertyNode(row,col,value){\r\n        this.#nodes[row][col].isWall = value;\r\n    }\r\n\r\n    getNodes(){\r\n        return this.#nodes;\r\n    }\r\n\r\n    getAllNodes(){\r\n        const nodes = [];\r\n        for (let i = 0; i < this.#nodes.length; i++) {\r\n            const row = this.#nodes[i];\r\n            for (let j = 0; j < row.length; j++) {\r\n                nodes.push(row[j]);\r\n            }\r\n        }\r\n        return nodes;\r\n    }\r\n\r\n    getNodesSortedByDistance(){        \r\n        const nodes = [];\r\n        for (let i = 0; i < this.#nodes.length; i++) {\r\n            const row = this.#nodes[i];\r\n            for (let j = 0; j < row.length; j++) {\r\n                nodes.push(row[j]);\r\n            }\r\n        }\r\n\r\n        nodes.sort((a,b) => a.distance - b.distance)\r\n        return nodes;\r\n    }\r\n\r\n    isTargetNode(node){\r\n        return this.targetNode.row === node.row && this.targetNode.col === node.col;\r\n    }\r\n\r\n    isStartNode(node){\r\n        return this.startNode.row === node.row && this.startNode.col === node.col;\r\n    }\r\n\r\n    getUnvisitedNeighbors(node){\r\n        const neighbors = [];\r\n        const col = node.col;\r\n        const row = node.row;\r\n        if (row > 0) neighbors.push(this.#nodes[row - 1][col]);\r\n        if (row < this.#nodes.length - 1) neighbors.push(this.#nodes[row + 1][col]);\r\n        if (col > 0) neighbors.push(this.#nodes[row][col - 1]);\r\n        if (col < this.#nodes[0].length - 1) neighbors.push(this.#nodes[row][col + 1]);\r\n        return neighbors.filter(neighbor => !neighbor.isVisited);\r\n    }\r\n\r\n    updateUnvisitedNeighbors(node){\r\n        const unvisitedNeighbors = this.getUnvisitedNeighbors(node);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            neighbor.distance = node.distance + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n}","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\n\r\nimport {dijkstra, dijkstra_2, getNodesInShortestPathOrder} from '../algorithms/dijkstra';\r\nimport {Grid} from '../algorithms/node';\r\nimport './PathVisualizer.css';\r\n\r\nexport default class PathVisualizer extends Component {\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            grid: new Grid(20,50),\r\n            isMoussePressed:false\r\n        }\r\n    }\r\n\r\n    componentDidMount(){\r\n        const grid = this.state.grid;\r\n        grid.setStartNode(10,10);\r\n        grid.setTargetNode(10,40);\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    onMouseDown(row, col) {\r\n        const grid = this.state.grid;\r\n        grid.toogleWallPropertyNode(row, col);\r\n        this.setState({isMoussePressed: true});\r\n    }\r\n    \r\n    onMouseEnter(row, col) {\r\n        if (!this.state.isMoussePressed) \r\n            return;\r\n        const grid = this.state.grid;\r\n        grid.setWallPropertyNode(row, col, true);\r\n        this.setState({grid: grid});\r\n        // Check for future modifications:\r\n        // https://stackoverflow.com/questions/33080657/react-update-one-item-in-a-list-without-recreating-all-items\r\n    }\r\n    \r\n    onMouseUp() {\r\n        this.setState({isMoussePressed: false});\r\n    }\r\n\r\n    computeDijkstra() {\r\n        // Variables\r\n        const {grid} = this.state;\r\n\r\n        // Computes \r\n        const visitedNodesInOrder = dijkstra_2(grid);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid.targetNode);\r\n        this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n\r\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n          if (i === visitedNodesInOrder.length) {\r\n            setTimeout(() => {\r\n              this.animateShortestPath(nodesInShortestPathOrder);\r\n            }, 10 * i);\r\n            return;\r\n          }\r\n          setTimeout(() => {\r\n            const node = visitedNodesInOrder[i];\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node node-visited';\r\n          }, 10 * i);\r\n        }\r\n    }\r\n\r\n    animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n          setTimeout(() => {\r\n            const node = nodesInShortestPathOrder[i];\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node node-shortest-path';\r\n          }, 50 * i);\r\n        }\r\n    }\r\n\r\n    render(){\r\n        const {grid} = this.state;\r\n        console.log(grid);\r\n\r\n        return(\r\n            <div>\r\n                <button onClick={() => this.computeDijkstra()}>\r\n                    Visualize Dijkstra's Algorithm\r\n                </button>\r\n                <div className=\"grid\"> \r\n                    {grid.getNodes().map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx}>\r\n                                {row.map((node, nodeIdx)=> {\r\n                                    const row = node.row;\r\n                                    const col = node.col; \r\n                                    return <Node \r\n                                        key={nodeIdx}\r\n                                        row={row}\r\n                                        col={col}\r\n                                        isStart={grid.isStartNode(node)}\r\n                                        isTarget={grid.isTargetNode(node)}\r\n                                        isWall={node.isWall}\r\n                                        onMouseDown={(row, col) => this.onMouseDown(row, col)}\r\n                                        onMouseEnter={(row, col) => this.onMouseEnter(row, col)}\r\n                                        onMouseUp={() => this.onMouseUp()}\r\n                                    ></Node>\r\n                                })}\r\n                            </div>\r\n                        )\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import './App.css';\nimport PathVisualizer from './PathVisualizer/PathVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathVisualizer></PathVisualizer>\n    </div>\n  );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}